<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>583 Project</title>


    <!-- Pico.css -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <!-- Load Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <!-- Load d3.js for CSV parsing -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Load turf.js for point-in-polygon -->
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

    <style>
        #map {
            width: 100%;
            height: 400px;
          }

        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }

        .leaflet-tooltip {
            font-size: 16px;
        }
    </style>


</head>

<body>
  
<!-- Header -->
    <header class="container">

      <h4>*Note</h4>
      <p>Please allow a minute or two for the choropleth location data to load, as the dataset is quite large.</p>
      <p>The webpage may freeze briefly when being initially loaded or say 'Page Unresponsive', simply hit 'Wait' and the data will load shortly.</p>
      <p>You will know when it is loaded as there will be blue and red sections overlayed onto the map.</p>
      
      <h4>*Note 2</h4>
      <p>We have changed and upgraded our visualizations that we described in our presentation slides during our in class presentation, based on feedback we recieved.</p>
      <p>We hope that the new visualizations are much better designed than the ones in our presentation slides, please feel free to compare them to our presentation slide ones.</p>


    </header>
    <!-- Header -->
    <header class="container">
        <hgroup>
            <h1>San Antonio Traffic Stop Project - Group 13</h1>
            <h2>Welcome to our CPSC 583 final project. We used the 2019 San Antonio traffic stop dataset, 
              which consists of data on police traffic stops done throughout the city. 
          The three main questions we wanted to explore were: Where in the city are these traffic stops taking place, and are these places signifigant? Are there any 
          conclusions that can be made from the demographic distribution of traffic stops? What does the distribution of traffic stops look like throughout the day, and why?
          Below you will find the visualizations we made to help answer these questions.</h2>
        </hgroup>

    </header>
    <!-- ./ Header -->

    <!-- Main -->
    <main class="container">

        <!-- Map section -->
        <section id="choropleth">
            <h2>Interactive Choropleth Map of San Antonio</h2>
            <p>
              Below is an interactive choropleth map of San Antonio. The user can zoom in and out with the scroll wheel. A geoJson file of the San Antonio Police Department patrol
              districts is overlayed on the map. By clicking on any of the districts, you will be presented with stacked barplots that break down the gender and race proportion
              for each violation type done in those districts. Note that speeding can often be a large majority of the violation types (although not always),
              so it has been seperated for easier readability.
            </p>
            <p>
                Click on a district section to begin seeing the barplots. On the left are the speeding only stacked barplots, and on the right are the rest of the violations. 
              You can mouse over each section to see the demographic name and value. The bottom two charts show the sex and race proportion for all traffic stops, so one can compare these
              ratios to those of the different districts.
            </p>

            <div class="grid">
                <div id="map"></div>
            </div>




            <div class="grid">


                <div id="sex_speed">
                </div>
                <div id="sex_rest">
                </div>




            </div>

            <div class="grid">



                <div id="race_speed">
                </div>
                <div id="race_rest">
                </div>

            </div>
          
            <div class="grid">



                <div id="total_sex">
                </div>
                <div id="total_race">
                </div>

            </div>
          
         
          
            <h3>Reflections of the Choropleth Map and Stacked Bar Charts</h3>
            <p>
             The total race distribution for all stops roughly matches the actual racial demographic in the city, although the male to female stop ratio
              has more men represented than the sex ratio of the city which is around 51% men and 49% women.
      
            </p>
            <p>
            One noticeable trend is the concentration of traffic stops on the four major roads leading in and out of the city, namely the interstate 10 west and east, 
              highway 90, and highway 281. These roads have solid red sections indicating high density traffic stop districts. In these areas, speeding violations constitute 
              the majority of traffic stops, with 'use of phone' also consistently high compared to the other non-speeding violations. 
              These large roads connecting the city to the rest of the country seem to be the preferred locations for police to set up and catch speeders, as well as individuals 
              using their phones while driving. The data shows that men make up slightly over half of the drivers stopped 
              for both speeding and phone use in these areas, with no significant racial bias apparent in the proportion of traffic stops compared to city-wide. This suggests that police are 
              stopping whoever they see breaking traffic laws in these areas.
      
            </p>
            <p>
            In central San Antonio, there is an increase in police traffic stop activity concentrated east of the South Pan Am Expressway, west of the William J Bordelon Freeway, 
              and north of the George Lopez Freeway,
              right in the middle of downtown. Unlike the large highways which have up to around 2500 speeding instances, the number of traffic stops for speeding in these areas drops 
              to only several hundred. Instead, the most common non-speeding 
              violation is public intoxication, which is not surprising given the numerous bars in the area. Men constitute the majority of public intoxication violations, although the
              proportion of races again remains similar to the city one. In areas where there are elementary and high schools, school zone speeding tickets jump drastically. Most 
              patrol districts with schools have a even number of men and women with school zone speeding violations. Just to the north of downtown is San Antonio college, and the number 
              of public intoxication violations spikes here as well, as to be expected from a college age demographic that is partying often.  
              
              
          </p>
            <p>
              We can see some gaps in the map, with no recorded police traffic stops. These areas are military camps, and other areas where the San Antonio police
              do not patrol like the incorporated city of Alamo heights. 
              
              
          </p>



        </section>

        <!-- Stacked chart -->
        <section id="stackedarea">
            <h2>Stacked Area Chart of Age and Violations</h2>
            <p>
              What about how violations look like by age? Below is a stacked area chart that shows a breakdown of the violation type by age. The user 
              can zoom in on a section by dragging the mouse, and zoom out by double clicking. By mousing over the violations on the legend, those sections
              of the stacked area chart will be highlighted for easier viewing.
            </p>

            <div class="grid">
                <div id="stacked_chart"></div>
            </div>
          
          
            <h3>Reflections of the Stacked Area Chart</h3>
            <p>
            The first thing we noticed when looking at this chart was to see how much of the relative value speeding contributes to the violations compared to the 
              other violations. The distribution appears to be a logrithmic distribution, and when zooming in on the large hump we can see the peek age for violations is around 
              23 years old. Petty Theft, Soliciting and Drugs appear to be the most evenly distributed so these violations are done consistantly by all ages. Compare that to the steeper
              drop off in Speeding after the mid 20's, we can see as people get older they become much less likely to speed.
      
            </p>





        </section>



        <!-- Heat map -->
        <section id="heatmaparea">
            <h2>Heat Map of Traffic Stop Times</h2>
            <p>
              Below are heat maps that shows how traffic stops are distributed through the days of the week, by the hour. The first heat map shows the data for the entire year,
              while the second is per month, with a slider that allows you to select which month you want to observe. You can mouse over any heatmap cell to see the day, time and number
              of stops. 
            </p>

            <div class="grid">
                <div id="myDiv2"></div>
            </div>

            <div class="grid">
                <div id="myDiv"></div>
            </div>
            <div class="grid">
                <div class="slidecontainer">
                    <input type="range" min="0" max="11" value="0" class="slider" id="myRange">
                    <output><span id="demo"></span></output>
                </div>
            </div>
          
          
            <h3>Reflections of the Heat Map of Traffic Stop Times</h3>
            <p>
            Policemen turn up the traffic stops mid week, but the traffic stops seem to pause on the weekend. 7am to 3pm are the real hot times for traffic stops mid week, 
            which matches closely to the most common 'B' day shift that the San Antonio police department has, which is 6am to 2pm. Scrolling through the month by month weekly
            breakdown we see the times the police are active on traffic stops stays fairly consistent, although sometimes Monday and Friday will get a bit higher proportion of stops. 
              Police seem to enjoy a weekend off as much as the rest of us do based on the stop distribution of these days. 
            </p>
          
   

        </section>




    </main>
    <!-- ./ Main -->



</body>


<script>

    function mapsection() {


        // Create the map and set the center and zoom level
        const map = L.map('map').setView([29.4241, -98.4936], 9.5);

        // Add a base map from OpenStreetMap
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Load CSV data and parse latitude and longitude values
        async function loadCsvData(file) {
            const data = await d3.csv(file);
            return data
                .filter(d => !isNaN(parseFloat(d.lat)) && !isNaN(parseFloat(d.lng)))
                .map(d => {
                    return {
                        lat: parseFloat(d.lat),
                        lng: parseFloat(d.lng),
                        violation: d.violation,
                        sex: d.subject_sex,
                        race: d.subject_race

                    };
                });

        }

        function countPointsInFeature(feature, points) {
            let count = 0;

            points.forEach(point => {
                const pointFeature = turf.point([point.lng, point.lat]);
                if (turf.booleanPointInPolygon(pointFeature, feature)) {
                    count++;
                }
            });

            return count;
        }

        function computeDataForRegion(feature, points) {
            const violationCounts = {};

            points.forEach(point => {
                const pointFeature = turf.point([point.lng, point.lat]);
                if (turf.booleanPointInPolygon(pointFeature, feature)) {
                    const { violation, sex, race } = point;
                    if (!violationCounts[violation]) {
                        violationCounts[violation] = { male: 0, female: 0, asian_pacificislander: 0, black: 0, hispanic: 0, other: 0, white: 0 };
                    }
                    if (sex === "male") {
                        violationCounts[violation].male += 1;
                    } else if (sex === "female") {
                        violationCounts[violation].female += 1;
                    }
                    if (race === "asian/pacific islander") {
                        violationCounts[violation].asian_pacificislander += 1;
                    }
                    if (race === "black") {
                        violationCounts[violation].black += 1;
                    }
                    if (race === "hispanic") {
                        violationCounts[violation].hispanic += 1;
                    }
                    if (race === "other") {
                        violationCounts[violation].other += 1;
                    }
                    if (race === "white") {
                        violationCounts[violation].white += 1;
                    }
                }
            });

            const data = Object.entries(violationCounts).map(([violation, counts]) => {
                return {
                    violations: violation, male: counts.male, female: counts.female, asian_pacificislander: counts.asian_pacificislander,
                    black: counts.black, hispanic: counts.hispanic, other: counts.other, white: counts.white
                };
            });

            return data;
        }

        // Color scale
        const colorScale = d3.scaleLinear()
            .domain([0, 2500]) // Adjust the domain based on the maximum number of points in a feature
            .range(["blue", "red"]);


        // Load the GeoJSON and CSV files and add the GeoJSON to the map with scaled colors
        Promise.all([
            fetch('https://cdn.glitch.global/89ce0c17-1242-4272-9e89-79512ce449b1/SAPD_Districts.geojson?v=1681621989294').then(response => response.json()),
            loadCsvData('sanAntonio_2019_cleaned_final.csv')
        ]).then(([geoData, csvData]) => {
            L.geoJSON(geoData, {
                // Customize the style of the GeoJSON features
                style: function (feature) {
                    const pointsInFeature = countPointsInFeature(feature, csvData);
                    const fillColor = colorScale(pointsInFeature);

                    return {
                        color: '#333',
                        weight: 1,
                        fillColor: fillColor,
                        fillOpacity: 0.5 // Set the fill opacity to make the overlay slightly translucent
                    };
           
                },
              


                // Add mouseover and mouseout event handlers
                onEachFeature: function (feature, layer) {
                    const pointsInFeature = countPointsInFeature(feature, csvData);
                  
                    

                    // Create a tooltip for the layer
                    const tooltipContent = `<strong>Traffic Stops:</strong> ${pointsInFeature}`;
                    layer.bindTooltip(tooltipContent, { permanent: false, direction: 'top', className: 'custom-tooltip' });

                    layer.on({
                        mouseover: function (e) {
                            const targetLayer = e.target;
                            targetLayer.setStyle({
                                weight: 3,
                                fillOpacity: 0.7
                            });
                        },
                        mouseout: function (e) {
                            const targetLayer = e.target;
                            targetLayer.setStyle({
                                weight: 1,
                                fillOpacity: 0.5
                            });
                        },
                        click: function (e) {
                            const targetFeature = e.target.feature;
                            const selectedData = computeDataForRegion(targetFeature, csvData);
                            updateChart1(selectedData);
                            updateChart2(selectedData);
                            updateChart3(selectedData);
                            updateChart4(selectedData);
    

                        },


                    });
                }
            }).addTo(map);
          
          updateChart5(csvData);
          updateChart6(csvData);
        }).catch(error => console.error('Error loading GeoJSON or CSV    :', error));


        // Create a color scale legend
        const legend = L.control({ position: 'bottomright' });

        legend.onAdd = function () {
            const div = L.DomUtil.create('div', 'info legend');
            const grades = [0, 625, 1250, 1875, 2500]; // Adjust these values based on the range of points in your features
            const labels = [];

            // Add title to the legend
            div.innerHTML = '<strong># Traffic Stops</strong><br>';

            // Generate a label with a colored square for each interval
            grades.forEach((grade, i) => {
                const from = grade;
                const to = grades[i + 1];
                const color = colorScale(grade);

                labels.push(
                    `<i style="background:${color}"></i> ${from}${to ? `&ndash;${to}` : '+'}`
                );
            });

            div.innerHTML += labels.join('<br>');
            return div;
        };

        legend.addTo(map);




        // chart dimensions ////////////////////////////////////////////////////////////////////////////////////////////////////


        // set the dimensions and margins of the graph
        const margin = { top: 30, right: 30, bottom: 80, left: 50 },
            width = 460 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        const svg1 = d3.select("#sex_rest")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // append the svg object to the body of the page
        const svg2 = d3.select("#sex_speed")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);


        // append the svg object to the body of the page
        const svg3 = d3.select("#race_rest")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // append the svg object to the body of the page
        const svg4 = d3.select("#race_speed")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
      
              // append the svg object to the body of the page
        const svg5 = d3.select("#total_sex")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
      
      
                    // append the svg object to the body of the page
        const svg6 = d3.select("#total_race")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
      
      
      
      
        // update the chart6 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function updateChart6(data) {
            // console.log(data);

            const uniqueViolations = [
                "No Insurance",
                "No Registration",
                "No License",
                "Drugs",
                "Public Intoxication",
                "Soliciting",
                "School Zone Speeding",
                "Petty Theft",
                "Use of Phone",
            ];

            const newData = data.filter((d) => uniqueViolations.includes(d.violation));
          
                      // Aggregate the data by violation and sex
            const aggregatedData = uniqueViolations.map((violation) => {
                const white = newData.filter(
                    (d) => d.violation === violation && d.race === "white"
                ).length;
                const black = newData.filter(
                    (d) => d.violation === violation && d.race === "black"
                ).length;
                const hispanic = newData.filter(
                    (d) => d.violation === violation && d.race === "hispanic"
                ).length;
                const other = newData.filter(
                    (d) => d.violation === violation && d.race === "other"
                ).length;
                const asian_pacificislander = newData.filter(
                    (d) => d.violation === violation && d.race === "asian/pacific islander"
                ).length;

                return { violation, white, black, hispanic, asian_pacificislander, other };
            });
          
          
              const totalData = aggregatedData.reduce(
                (acc, curr) => {
                    acc.white += curr.white;
                    acc.black += curr.black;
                    acc.hispanic += curr.hispanic;
                    acc.asian_pacificislander += curr.asian_pacificislander;
                    acc.other += curr.other;
                    return acc;
                },
                { violation: "Violations", white: 0, black: 0, hispanic: 0, asian_pacificislander: 0, other: 0 }
            );

          
            // Replace newData with aggregatedData in the following lines:
           const highestSum = totalData.white + totalData.black + totalData.hispanic + totalData.asian_pacificislander + totalData.other;
          
          

          
              // Add chart title
            svg6.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "20px")
                .style("text-decoration", "underline")
                .text("Total Race Distribution for All Stops");

            // Parse the Data

             // List of subgroups = header of the csv files = subject sex, could be race later
            const subgroups = ["white", "black", "hispanic", "asian_pacificislander", "other"];
          
              const stackedData = d3.stack().keys(subgroups)([totalData]);

            // Add X axis
            const x = d3.scaleBand()
                .domain(["Violations"])
                .range([0, width])
                .padding([0.2])
            svg6.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x).tickSizeOuter(0))
                .selectAll("text") // Select all the text elements in the x-axis
                .attr("y", 0) // Position the text vertically
                .attr("x", -9) // Shift the text horizontally
                .attr("dy", ".35em") // Apply a small vertical offset
                .attr("transform", "rotate(-45)") // Rotate the text 45 degrees counter-clockwise
                .style("text-anchor", "end"); // Anchor the text at the end (right side)



            // Add Y axis
            const y = d3.scaleLinear()
                .domain([0, highestSum])
                .range([height, 0]);
            svg6.append("g")
                .call(d3.axisLeft(y));

            // color palette = one color per subgroup
            const color = d3.scaleOrdinal()
                .domain(subgroups)
                .range(['lightgreen', 'purple', 'orange', 'brown', 'red'])



            // ----------------
            // Create a tooltip
            // ----------------

            // Remove any existing tooltip
            d3.select("#total_race").select(".tooltip").remove();


            const tooltip = d3.select("#total_race")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "1px")
                .style("border-radius", "5px")
                .style("padding", "10px")



            // Three function that change the tooltip when user hover / move / leave a cell
            const mouseover = function (event, d) {
                const subgroupName = d3.select(this.parentNode).datum().key;
                const subgroupValue = d.data[subgroupName];
                tooltip
                    .html("subgroup: " + subgroupName + "<br>" + "amount: " + subgroupValue)
                    .style("opacity", 1)

            }
            const mousemove = function (event, d) {
                tooltip.style("transform", "translateY(-55%)")
                    .style("left", (event.x) / 2 + "px")
                    .style("top", (event.y) / 2 - 20 + "px")
            }
            const mouseleave = function (event, d) {
                tooltip
                    .style("opacity", 0)
            }

            // Show the bars
            svg6.append("g")
                .selectAll("g")
                // Enter in the stack data = loop key per key = group per group
                .data(stackedData)
                .join("g")
                .attr("fill", d => color(d.key))
                .selectAll("rect")
                // enter a second time = loop subgroup per subgroup to add all rectangles
                .data(d => d)
                .join("rect")
                .attr("x", () => x("Violations"))
                .attr("y", height) // Initially set y attribute to the height of the chart
                .attr("height", 0) // Initially set the height of the bars to 0
                .attr("width", x.bandwidth())
                .attr("stroke", "grey")
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseleave", mouseleave)
                .transition() // Apply a transition
                .duration(1000) // Set the duration of the transition in milliseconds
                .attr("y", d => y(d[1])) // Animate the y attribute to its final position
                .attr("height", d => y(d[0]) - y(d[1])); // Animate the height of the bars to their final height
            // ...


        }
      

      
      
        // update the chart5 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function updateChart5(data) {
            // console.log(data);

            const uniqueViolations = [
                "No Insurance",
                "No Registration",
                "No License",
                "Drugs",
                "Public Intoxication",
                "Soliciting",
                "School Zone Speeding",
                "Petty Theft",
                "Use of Phone",
            ];

            const newData = data.filter((d) => uniqueViolations.includes(d.violation));
          
                      // Aggregate the data by violation and sex
            const aggregatedData = uniqueViolations.map((violation) => {
                const male = newData.filter(
                    (d) => d.violation === violation && d.sex === "male"
                ).length;
                const female = newData.filter(
                    (d) => d.violation === violation && d.sex === "female"
                ).length;

                return { violation, male, female };
            });
          
          
              const totalData = aggregatedData.reduce(
                (acc, curr) => {
                    acc.male += curr.male;
                    acc.female += curr.female;
                    return acc;
                },
                { violation: "Violations", male: 0, female: 0 }
            );

          
                      // Replace newData with aggregatedData in the following lines:
           const highestSum = totalData.male + totalData.female;
          
          

          
              // Add chart title
            svg5.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "20px")
                .style("text-decoration", "underline")
                .text("Total Sex Distribution for All Stops");

            // Parse the Data

             // List of subgroups = header of the csv files = subject sex, could be race later
            const subgroups = ["male", "female"];
          
              const stackedData = d3.stack().keys(subgroups)([totalData]);

            // Add X axis
            const x = d3.scaleBand()
                .domain(["Violations"])
                .range([0, width])
                .padding([0.2])
            svg5.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x).tickSizeOuter(0))
                .selectAll("text") // Select all the text elements in the x-axis
                .attr("y", 0) // Position the text vertically
                .attr("x", -9) // Shift the text horizontally
                .attr("dy", ".35em") // Apply a small vertical offset
                .attr("transform", "rotate(-45)") // Rotate the text 45 degrees counter-clockwise
                .style("text-anchor", "end"); // Anchor the text at the end (right side)



            // Add Y axis
            const y = d3.scaleLinear()
                .domain([0, highestSum])
                .range([height, 0]);
            svg5.append("g")
                .call(d3.axisLeft(y));

            // color palette = one color per subgroup
            const color = d3.scaleOrdinal()
                .domain(subgroups)
                .range(['blue', 'pink'])



            // ----------------
            // Create a tooltip
            // ----------------

            // Remove any existing tooltip
            d3.select("#total_sex").select(".tooltip").remove();


            const tooltip = d3.select("#total_sex")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "1px")
                .style("border-radius", "5px")
                .style("padding", "10px")



            // Three function that change the tooltip when user hover / move / leave a cell
            const mouseover = function (event, d) {
                const subgroupName = d3.select(this.parentNode).datum().key;
                const subgroupValue = d.data[subgroupName];
                tooltip
                    .html("subgroup: " + subgroupName + "<br>" + "amount: " + subgroupValue)
                    .style("opacity", 1)

            }
            const mousemove = function (event, d) {
                tooltip.style("transform", "translateY(-55%)")
                    .style("left", (event.x) / 2 + "px")
                    .style("top", (event.y) / 2 - 20 + "px")
            }
            const mouseleave = function (event, d) {
                tooltip
                    .style("opacity", 0)
            }

            // Show the bars
            svg5.append("g")
                .selectAll("g")
                // Enter in the stack data = loop key per key = group per group
                .data(stackedData)
                .join("g")
                .attr("fill", d => color(d.key))
                .selectAll("rect")
                // enter a second time = loop subgroup per subgroup to add all rectangles
                .data(d => d)
                .join("rect")
                .attr("x", () => x("Violations"))
                .attr("y", height) // Initially set y attribute to the height of the chart
                .attr("height", 0) // Initially set the height of the bars to 0
                .attr("width", x.bandwidth())
                .attr("stroke", "grey")
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseleave", mouseleave)
                .transition() // Apply a transition
                .duration(1000) // Set the duration of the transition in milliseconds
                .attr("y", d => y(d[1])) // Animate the y attribute to its final position
                .attr("height", d => y(d[0]) - y(d[1])); // Animate the height of the bars to their final height
            // ...


        }
      
      
      
      





        // update the chart1 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function updateChart1(data) {
            // console.log(data);

            const newData = data.filter(d => d.violations !== 'Speeding');

            // Clear the existing charts
            svg1.selectAll("*").remove();
          
              // Add chart title
            svg1.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "20px")
                .style("text-decoration", "underline")
                .text("Non-speeding Violations by Sex");

            // Parse the Data

            // violations
            const uniqueViolations = ["No Insurance",
                "No Registration", "No License",
                "Drugs", "Public Intoxication", "Soliciting",
                "School Zone Speeding",
                "Petty Theft", "Use of Phone"];
            console.log(uniqueViolations);

            // List of subgroups = header of the csv files = subject sex, could be race later
            const subgroups = ["male", "female"];

            // Add X axis
            const x = d3.scaleBand()
                .domain(uniqueViolations)
                .range([0, width])
                .padding([0.2])
            svg1.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x).tickSizeOuter(0))
                .selectAll("text") // Select all the text elements in the x-axis
                .attr("y", 0) // Position the text vertically
                .attr("x", -9) // Shift the text horizontally
                .attr("dy", ".35em") // Apply a small vertical offset
                .attr("transform", "rotate(-45)") // Rotate the text 45 degrees counter-clockwise
                .style("text-anchor", "end"); // Anchor the text at the end (right side)


            const highestSum = newData.reduce((max, obj) => {
                const sum = obj.male + obj.female;
                return sum > max ? sum : max;
            }, 0);

            // Add Y axis
            const y = d3.scaleLinear()
                .domain([0, highestSum])
                .range([height, 0]);
            svg1.append("g")
                .call(d3.axisLeft(y));

            // color palette = one color per subgroup
            const color = d3.scaleOrdinal()
                .domain(subgroups)
                .range(['blue', 'pink'])

            //stack the data? --> stack per subgroup
            const stackedData = d3.stack()
                .keys(subgroups)
                (newData)


            // ----------------
            // Create a tooltip
            // ----------------

            // Remove any existing tooltip
            d3.select("#sex_rest").select(".tooltip").remove();


            const tooltip = d3.select("#sex_rest")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "1px")
                .style("border-radius", "5px")
                .style("padding", "10px")



            // Three function that change the tooltip when user hover / move / leave a cell
            const mouseover = function (event, d) {
                const subgroupName = d3.select(this.parentNode).datum().key;
                const subgroupValue = d.data[subgroupName];
                tooltip
                    .html("subgroup: " + subgroupName + "<br>" + "amount: " + subgroupValue)
                    .style("opacity", 1)

            }
            const mousemove = function (event, d) {
                tooltip.style("transform", "translateY(-55%)")
                    .style("left", (event.x) / 2 + "px")
                    .style("top", (event.y) / 2 - 20 + "px")
            }
            const mouseleave = function (event, d) {
                tooltip
                    .style("opacity", 0)
            }

            // Show the bars
            svg1.append("g")
                .selectAll("g")
                // Enter in the stack data = loop key per key = group per group
                .data(stackedData)
                .join("g")
                .attr("fill", d => color(d.key))
                .selectAll("rect")
                // enter a second time = loop subgroup per subgroup to add all rectangles
                .data(d => d)
                .join("rect")
                .attr("x", d => x(d.data.violations))
                .attr("y", height) // Initially set y attribute to the height of the chart
                .attr("height", 0) // Initially set the height of the bars to 0
                .attr("width", x.bandwidth())
                .attr("stroke", "grey")
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseleave", mouseleave)
                .transition() // Apply a transition
                .duration(1000) // Set the duration of the transition in milliseconds
                .attr("y", d => y(d[1])) // Animate the y attribute to its final position
                .attr("height", d => y(d[0]) - y(d[1])); // Animate the height of the bars to their final height
            // ...


        }
      
      
      
      
      

        //////////////////// update chart 2 ///////////////////////////////////////////////////////////////////////
        function updateChart2(data) {
            console.log(data);

            let newdata = data.filter(d => d.violations === 'Speeding');

            console.log(newdata);

            // Clear the existing chart
            svg2.selectAll("*").remove();
          
                        // Add chart title
            svg2.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "20px")
                .style("text-decoration", "underline")
                .text("Speeding Violations by Sex");


            // Parse the Data

            // violations
            const uniqueViolations = Array.from(new Set(newdata.map(item => item.violations)));
            console.log(uniqueViolations);

            // List of subgroups = header of the csv files = subject sex, could be race later
            const subgroups = ["male", "female"];

            // Add X axis
            const x = d3.scaleBand()
                .domain(uniqueViolations)
                .range([0, width])
                .padding([0.2])
            svg2.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x).tickSizeOuter(0))
                .selectAll("text") // Select all the text elements in the x-axis
                .attr("y", 0) // Position the text vertically
                .attr("x", -9) // Shift the text horizontally
                .attr("dy", ".35em") // Apply a small vertical offset
                .attr("transform", "rotate(-45)") // Rotate the text 45 degrees counter-clockwise
                .style("text-anchor", "end"); // Anchor the text at the end (right side)


            const highestSum = newdata.reduce((max, obj) => {
                const sum = obj.male + obj.female;
                return sum > max ? sum : max;
            }, 0);

            // Add Y axis
            const y = d3.scaleLinear()
                .domain([0, highestSum])
                .range([height, 0]);
            svg2.append("g")
                .call(d3.axisLeft(y));

            // color palette = one color per subgroup
            const color = d3.scaleOrdinal()
                .domain(subgroups)
                .range(['blue', 'pink'])

            //stack the data? --> stack per subgroup
            const stackedData = d3.stack()
                .keys(subgroups)
                (newdata)


            // ----------------
            // Create a tooltip
            // ----------------

            // Remove any existing tooltip
            d3.select("#sex_speed").select(".tooltip").remove();


            const tooltip = d3.select("#sex_speed")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "1px")
                .style("border-radius", "5px")
                .style("padding", "10px")


            // Three function that change the tooltip when user hover / move / leave a cell
            const mouseover = function (event, d) {
                const subgroupName = d3.select(this.parentNode).datum().key;
                const subgroupValue = d.data[subgroupName];
                tooltip
                    .html("subgroup: " + subgroupName + "<br>" + "amount: " + subgroupValue)
                    .style("opacity", 1)

            }
            const mousemove = function (event, d) {
                tooltip.style("transform", "translateY(-55%)")
                    .style("left", (event.x) / 2 + "px")
                    .style("top", (event.y) / 2 - 20 + "px")
            }
            const mouseleave = function (event, d) {
                tooltip
                    .style("opacity", 0)
            }

            // Show the bars
            svg2.append("g")
                .selectAll("g")
                // Enter in the stack data = loop key per key = group per group
                .data(stackedData)
                .join("g")
                .attr("fill", d => color(d.key))
                .selectAll("rect")
                // enter a second time = loop subgroup per subgroup to add all rectangles
                .data(d => d)
                .join("rect")
                .attr("x", d => x(d.data.violations))
                .attr("y", height) // Initially set y attribute to the height of the chart
                .attr("height", 0) // Initially set the height of the bars to 0
                .attr("width", x.bandwidth())
                .attr("stroke", "grey")
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseleave", mouseleave)
                .transition() // Apply a transition
                .duration(1000) // Set the duration of the transition in milliseconds
                .attr("y", d => y(d[1])) // Animate the y attribute to its final position
                .attr("height", d => y(d[0]) - y(d[1])); // Animate the height of the bars to their final height
            // ...



        }


        // update the chart3 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function updateChart3(data) {
            // console.log(data);

            const newData = data.filter(d => d.violations !== 'Speeding');

            // Clear the existing chart
            svg3.selectAll("*").remove();
          
                                  // Add chart title
            svg3.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "20px")
                .style("text-decoration", "underline")
                .text("Non-speeding Violations by Race");

            // Parse the Data

            // violations
            const uniqueViolations = ["No Insurance",
                "No Registration", "No License",
                "Drugs", "Public Intoxication", "Soliciting",
                "School Zone Speeding",
                "Petty Theft", "Use of Phone"];
            console.log(uniqueViolations);

            // List of subgroups = header of the csv files = subject sex, could be race later
            const subgroups = ["white", "black", "hispanic", "asian_pacificislander", "other"];

            // Add X axis
            const x = d3.scaleBand()
                .domain(uniqueViolations)
                .range([0, width])
                .padding([0.2])
            svg3.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x).tickSizeOuter(0))
                .selectAll("text") // Select all the text elements in the x-axis
                .attr("y", 0) // Position the text vertically
                .attr("x", -9) // Shift the text horizontally
                .attr("dy", ".35em") // Apply a small vertical offset
                .attr("transform", "rotate(-45)") // Rotate the text 45 degrees counter-clockwise
                .style("text-anchor", "end"); // Anchor the text at the end (right side)


            const highestSum = newData.reduce((max, obj) => {
                const sum = obj.male + obj.female;
                return sum > max ? sum : max;
            }, 0);

            // Add Y axis
            const y = d3.scaleLinear()
                .domain([0, highestSum])
                .range([height, 0]);
            svg3.append("g")
                .call(d3.axisLeft(y));

            // color palette = one color per subgroup
            const color = d3.scaleOrdinal()
                .domain(subgroups)
                .range(['lightgreen', 'purple', 'orange', 'brown', 'red'])

            //stack the data? --> stack per subgroup
            const stackedData = d3.stack()
                .keys(subgroups)
                (newData)


            // ----------------
            // Create a tooltip
            // ----------------

            // Remove any existing tooltip
            d3.select("#race_rest").select(".tooltip").remove();


            const tooltip = d3.select("#race_rest")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "1px")
                .style("border-radius", "5px")
                .style("padding", "10px")


            // Three function that change the tooltip when user hover / move / leave a cell
            const mouseover = function (event, d) {
                const subgroupName = d3.select(this.parentNode).datum().key;
                const subgroupValue = d.data[subgroupName];
                tooltip
                    .html("subgroup: " + subgroupName + "<br>" + "amount: " + subgroupValue)
                    .style("opacity", 1)

            }
            const mousemove = function (event, d) {
                tooltip.style("transform", "translateY(-55%)")
                    .style("left", (event.x) / 2 + "px")
                    .style("top", (event.y) / 2 - 20 + "px")
            }
            const mouseleave = function (event, d) {
                tooltip
                    .style("opacity", 0)
            }

            // Show the bars
            svg3.append("g")
                .selectAll("g")
                // Enter in the stack data = loop key per key = group per group
                .data(stackedData)
                .join("g")
                .attr("fill", d => color(d.key))
                .selectAll("rect")
                // enter a second time = loop subgroup per subgroup to add all rectangles
                .data(d => d)
                .join("rect")
                .attr("x", d => x(d.data.violations))
                .attr("y", height) // Initially set y attribute to the height of the chart
                .attr("height", 0) // Initially set the height of the bars to 0
                .attr("width", x.bandwidth())
                .attr("stroke", "grey")
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseleave", mouseleave)
                .transition() // Apply a transition
                .duration(1000) // Set the duration of the transition in milliseconds
                .attr("y", d => y(d[1])) // Animate the y attribute to its final position
                .attr("height", d => y(d[0]) - y(d[1])); // Animate the height of the bars to their final height
            // ...


        }


        //////////////////// update chart 4 ///////////////////////////////////////////////////////////////////////
        function updateChart4(data) {
            console.log(data);

            let newdata = data.filter(d => d.violations === 'Speeding');

            console.log(newdata);

            // Clear the existing chart
            svg4.selectAll("*").remove();
          
                                            // Add chart title
            svg4.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "20px")
                .style("text-decoration", "underline")
                .text("Speeding Violations by Race");

            // Parse the Data

            // violations
            const uniqueViolations = Array.from(new Set(newdata.map(item => item.violations)));
            console.log(uniqueViolations);

            // List of subgroups = header of the csv files = subject sex, could be race later
            const subgroups = ["white", "black", "hispanic", "asian_pacificislander", "other"];

            // Add X axis
            const x = d3.scaleBand()
                .domain(uniqueViolations)
                .range([0, width])
                .padding([0.2])
            svg4.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x).tickSizeOuter(0))
                .selectAll("text") // Select all the text elements in the x-axis
                .attr("y", 0) // Position the text vertically
                .attr("x", -9) // Shift the text horizontally
                .attr("dy", ".35em") // Apply a small vertical offset
                .attr("transform", "rotate(-45)") // Rotate the text 45 degrees counter-clockwise
                .style("text-anchor", "end"); // Anchor the text at the end (right side)


            const highestSum = newdata.reduce((max, obj) => {
                const sum = obj.male + obj.female;
                return sum > max ? sum : max;
            }, 0);

            // Add Y axis
            const y = d3.scaleLinear()
                .domain([0, highestSum])
                .range([height, 0]);
            svg4.append("g")
                .call(d3.axisLeft(y));

            // color palette = one color per subgroup
            const color = d3.scaleOrdinal()
                .domain(subgroups)
                .range(['lightgreen', 'purple', 'orange', 'brown', 'red'])

            //stack the data? --> stack per subgroup
            const stackedData = d3.stack()
                .keys(subgroups)
                (newdata)


            // ----------------
            // Create a tooltip
            // ----------------


            // Remove any existing tooltip
            d3.select("#race_speed").select(".tooltip").remove();


            const tooltip = d3.select("#race_speed")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "1px")
                .style("border-radius", "5px")
                .style("padding", "10px")

            // Three function that change the tooltip when user hover / move / leave a cell
            const mouseover = function (event, d) {
                const subgroupName = d3.select(this.parentNode).datum().key;
                const subgroupValue = d.data[subgroupName];
                tooltip
                    .html("subgroup: " + subgroupName + "<br>" + "amount: " + subgroupValue)
                    .style("opacity", 1)

            }
            const mousemove = function (event, d) {
                tooltip.style("transform", "translateY(-55%)")
                    .style("left", (event.x) / 2 + "px")
                    .style("top", (event.y) / 2 - 30 + "px")
            }
            const mouseleave = function (event, d) {
                tooltip
                    .style("opacity", 0)
            }

            // Show the bars
            svg4.append("g")
                .selectAll("g")
                // Enter in the stack data = loop key per key = group per group
                .data(stackedData)
                .join("g")
                .attr("fill", d => color(d.key))
                .selectAll("rect")
                // enter a second time = loop subgroup per subgroup to add all rectangles
                .data(d => d)
                .join("rect")
                .attr("x", d => x(d.data.violations))
                .attr("y", height) // Initially set y attribute to the height of the chart
                .attr("height", 0) // Initially set the height of the bars to 0
                .attr("width", x.bandwidth())
                .attr("stroke", "grey")
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseleave", mouseleave)
                .transition() // Apply a transition
                .duration(1000) // Set the duration of the transition in milliseconds
                .attr("y", d => y(d[1])) // Animate the y attribute to its final position
                .attr("height", d => y(d[0]) - y(d[1])); // Animate the height of the bars to their final height
            // ...



        }

    }

    /////////////////// STACKED CODE //////////////////////////////////////////////////////////////////////////

    function stackedsection() {
        // set the dimensions and margins of the graph
        const margin = { top: 60, right: 600, bottom: 50, left: 50 },
            width = 1600 - margin.left - margin.right,
            height = 600 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        const svg = d3.select("#stacked_chart")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
                `translate(${margin.left}, ${margin.top})`);

        // Parse the Data
        // d3.csv("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/5_OneCatSevNumOrdered_wide.csv").then(function (data) {
        d3.csv("sanAntonio_2019_cleaned_ages.csv").then(function (data) {

            console.log(data);


            //////////
            // GENERAL //
            //////////

            // List of groups = header of the csv files
            const keys = data.columns.slice(1)

            // color palette
            const color = d3.scaleOrdinal()
                .domain(keys)
                .range(["#4e79a7", "#f28e2c", "#e15759", "#76b7b2", "#59a14f", "#edc949", "#af7aa1", "#ff9da7", "#9c755f", "#bab0ab"]);

            //stack the data?
            const stackedData = d3.stack()
                .keys(keys)
                (data)

            console.log(d3.extent(data, function (d) { return parseInt(d.subject_age); }));

            //////////
            // AXIS //
            //////////

            // Add X axis
            const x = d3.scaleLinear()
                .domain(d3.extent(data, function (d) { return parseInt(d.subject_age); }))
                .range([0, width]);
            const xAxis = svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x).ticks(5))

            // Add X axis label:
            svg.append("text")
                .attr("text-anchor", "end")
                .attr("x", width)
                .attr("y", height + 40)
                .text("Age of suspect");

            // Add Y axis label:
            svg.append("text")
                .attr("text-anchor", "end")
                .attr("x", 0)
                .attr("y", -20)
                .text("# of traffic stops")
                .attr("text-anchor", "start")

            // Add Y axis
            const y = d3.scaleLinear()
                .domain([0, 2500])
                .range([height, 0]);
            svg.append("g")
                .call(d3.axisLeft(y).ticks(5))



            //////////
            // BRUSHING AND CHART //
            //////////

            // Add a clipPath: everything out of this area won't be drawn.
            const clip = svg.append("defs").append("svg:clipPath")
                .attr("id", "clip")
                .append("svg:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Add brushing
            const brush = d3.brushX()                 // Add the brush feature using the d3.brush function
                .extent([[0, 0], [width, height]]) // initialise the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
                .on("end", updateChart) // Each time the brush selection changes, trigger the 'updateChart' function

            // Create the scatter variable: where both the circles and the brush take place
            const areaChart = svg.append('g')
                .attr("clip-path", "url(#clip)")

            // Area generator
            const area = d3.area()
                .x(function (d) { return x(d.data.subject_age); })
                .y0(function (d) { return y(d[0]); })
                .y1(function (d) { return y(d[1]); })

            // Show the areas
            areaChart
                .selectAll("mylayers")
                .data(stackedData)
                .join("path")
                .attr("class", function (d) { return "myArea " + d.key })
                .style("fill", function (d) { return color(d.key); })
                .attr("d", area)

            // Add the brushing
            areaChart
                .append("g")
                .attr("class", "brush")
                .call(brush);

            let idleTimeout
            function idled() { idleTimeout = null; }

            // A function that update the chart for given boundaries
            function updateChart(event, d) {

                extent = event.selection

                // If no selection, back to initial coordinate. Otherwise, update X axis domain
                if (!extent) {
                    if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // This allows to wait a little bit
                    x.domain(d3.extent(data, function (d) { return parseInt(d.subject_age); }))
                } else {
                    x.domain([x.invert(extent[0]), x.invert(extent[1])])
                    areaChart.select(".brush").call(brush.move, null) // This remove the grey brush area as soon as the selection has been done
                }

                // Update axis and area position
                xAxis.transition().duration(1000).call(d3.axisBottom(x).ticks(5))
                areaChart
                    .selectAll("path")
                    .transition().duration(1000)
                    .attr("d", area)
            }



            //////////
            // HIGHLIGHT GROUP //
            //////////

            // What to do when one group is hovered
            const highlight = function (event, d) {
                // reduce opacity of all groups
                d3.selectAll(".myArea").style("opacity", .1)
                // expect the one that is hovered
                d3.select("." + d).style("opacity", 1)
            }

            // And when it is not hovered anymore
            const noHighlight = function (event, d) {
                d3.selectAll(".myArea").style("opacity", 1)
            }



            //////////
            // LEGEND //
            //////////

            // Add one dot in the legend for each name.
            const size = 20
            svg.selectAll("myrect")
                .data(keys)
                .join("rect")
                .attr("x", 1000)
                .attr("y", function (d, i) { return 10 + i * (size + 5) }) // 100 is where the first dot appears. 25 is the distance between dots
                .attr("width", size)
                .attr("height", size)
                .style("fill", function (d) { return color(d) })
                .on("mouseover", highlight)
                .on("mouseleave", noHighlight)

            // Add one dot in the legend for each name.
            svg.selectAll("mylabels")
                .data(keys)
                .join("text")
                .attr("x", 1000 + size * 1.2)
                .attr("y", function (d, i) { return 10 + i * (size + 5) + (size / 2) }) // 100 is where the first dot appears. 25 is the distance between dots
                .style("fill", "black")
                .text(function (d) { return d })
                .attr("text-anchor", "left")
                .style("alignment-baseline", "middle")
                .on("mouseover", highlight)
                .on("mouseleave", noHighlight)

        })

    }


    /////////////// HEAT MAP SECTION //////////////////////////////////////////////////////////////////////////////////

    
  var slider = document.getElementById("myRange");
  var months = ["January", "February", "March", "April", "May", "June", "July", "August", "Sepember", "October", "November", "December"];
  document.getElementById("demo").innerHTML = months[0];

  slider.oninput = function () {
    document.getElementById("demo").innerHTML = months[slider.value];
  }

  slider.addEventListener('input', (event) => {
    const month = event.target.value;
    updateHeatmap(month);
  });

  // HEAT MAP OF ALL MONTHS

      // read in the csv with d3
      d3.csv(`sanAntonio_2019_cleaned_final.csv`).then((csvData) => {
      // Parse the time and extract the unique hours
      const uniqueHours = Array.from(
        new Set(
          csvData.map((row) =>
            d3.timeParse("%Y-%m-%d %H:%M:%S")(`${row.date} ${row.time}`).getHours()
          )
        )
      ).sort((a, b) => a - b);

      // Convert unique hours to 12-hour format with am/pm
      const uniqueHoursFormatted = uniqueHours.map((hour) => {
        const ampm = hour < 12 ? "am" : "pm";
        const hour12 = hour % 12 === 0 ? 12 : hour % 12;
        return `${hour12}${ampm}`;
      });

      // Process the data to create the desired structure
      const dayOfWeek = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
      const hourCounts = uniqueHours.map((hour) => {
        const hourArray = Array(7).fill(0);
        csvData.forEach((row) => {
          const date = d3.timeParse("%Y-%m-%d %H:%M:%S")(`${row.date} ${row.time}`);
          if (date.getHours() === hour) {
            const day = date.getDay();
            // Adjust the index because JavaScript's getDay() method returns 0 for Sunday, 1 for Monday, etc.
            const index = day === 0 ? 6 : day - 1;
            hourArray[index]++;
          }
        });
        return hourArray;
      });

      // Define the heatmap chart data
      const data = [
        {
          z: hourCounts,
          x: dayOfWeek,
          y: uniqueHoursFormatted,
          type: 'heatmap',
          hoverongaps: false,
          xgap: 15,
          hovertemplate: 'Day: %{x}<br>Time: %{y}<br>Stops: %{z}<extra></extra>',
        }
      ];

      // Render the chart
      Plotly.newPlot('myDiv2', data);


    });




  // DYNAMIC HEAT MAP MONTH TO MONTH
  function updateHeatmap(month) {
    // read in the csv with d3
    d3.csv(`sanAntonio_2019_cleaned_month_${month}.csv`).then((csvData) => {
      // Parse the time and extract the unique hours
      const uniqueHours = Array.from(
        new Set(
          csvData.map((row) =>
            d3.timeParse("%Y-%m-%d %H:%M:%S")(`${row.date} ${row.time}`).getHours()
          )
        )
      ).sort((a, b) => a - b);

      // Convert unique hours to 12-hour format with am/pm
      const uniqueHoursFormatted = uniqueHours.map((hour) => {
        const ampm = hour < 12 ? "am" : "pm";
        const hour12 = hour % 12 === 0 ? 12 : hour % 12;
        return `${hour12}${ampm}`;
      });

      // Process the data to create the desired structure
      const dayOfWeek = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
      const hourCounts = uniqueHours.map((hour) => {
        const hourArray = Array(7).fill(0);
        csvData.forEach((row) => {
          const date = d3.timeParse("%Y-%m-%d %H:%M:%S")(`${row.date} ${row.time}`);
          if (date.getHours() === hour) {
            const day = date.getDay();
            // Adjust the index because JavaScript's getDay() method returns 0 for Sunday, 1 for Monday, etc.
            const index = day === 0 ? 6 : day - 1;
            hourArray[index]++;
          }
        });
        return hourArray;
      });

      // Define the heatmap chart data
      const data = [
        {
          z: hourCounts,
          x: dayOfWeek,
          y: uniqueHoursFormatted,
          type: 'heatmap',
          hoverongaps: false,
          xgap: 15,
          hovertemplate: 'Day: %{x}<br>Time: %{y}<br>Stops: %{z}<extra></extra>',
        }
      ];

      // Render the chart
      Plotly.newPlot('myDiv', data);


    });
  }




  updateHeatmap(1);
  mapsection();
  stackedsection();








</script>



</html>